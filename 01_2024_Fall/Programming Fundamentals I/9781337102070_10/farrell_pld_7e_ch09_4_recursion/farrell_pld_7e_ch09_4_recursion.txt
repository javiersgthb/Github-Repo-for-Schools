

 
    
  
>> Hi, this is Joyce Farrell. 

    I want to tell you about recursion. 

    Let's look at a program that does not use recursion 

    so you can understand how methods are called. 

    This short program outputs an A, calls a method named method one 

    and then outputs a B. Let's assume method one outputs a C, 

    calls a method named method two and outputs a D. 

    And let's just assume method two outputs an E. 

    When these instructions are stored in computer memory, 

    each one has a memory address. 

    Computer memory addresses are usually represented 

    with numbers much larger than these, but any numbers will do, 

    so we're just going to number our instructions one 

    through thirteen. 

    When you run a computer program that calls methods, 

    there's a memory location called the stack 

    that holds the addresses of where the logic should return 

    to when each method is complete. 

    Let me show you what I mean. 

    When this program starts, 

    you output an A. Then you call method one. 

    But before you leave for method one, you have to remember 

    where to come back to when method one is complete. 

    So method one is stored at location three, so we're going 

    to save a three in the stack so we can remember 

    where to come back to. 

    Then we're going to execute method one. 

    We'll output a C and call method two. 

    But before we leave for method two, we have to remember 

    to come back here when method two is done. 

    So we'll save the eight in the stack. 

    Then we'll execute method two, which outputs an E. 

    When you return from method two, you take the top address 

    in the stack, and it tells you where to go back to. 

    It tells us to go back to the instruction 

    that follows instruction eight. 

    That would be instruction nine, output a D. When you return 

    from method one, you go into the stack again 

    and get the next place to return to. 

    That would be the instruction that followed instruction three. 

    That's instruction four, output a B. 

    And that's the end of the program. 

    Let's look at a different version of method one 

    that instead of calling method two, calls itself. 

    Method one is now a recursive method, 

    a method that calls itself. 

    When you start this program, you output A, 

    and you call method one. 

    But before you go there, you save the address to return to. 

    Then you execute method one 

    and output a C. Then you call method one again. 

    But before restarting method one, 

    you need to save the address to return to. 

    So we're going to save an eight in the stack. 

    Then you execute method one, output a C, 

    and call method one again, saving the place to return to. 

    You execute method one, output a C, and call method one again, 

    saving the place to return to. 

    Execute method one, output a C, call method one again, 

    and oops, stack overflow. 

    In a real computer program, you might be able to save thousands 

    of instructions of where to return 

    to before you had the stack overflow. 

    But eventually, there would just be too much. 

    It's an error. 

    Here's a way to fix it. 

    We're going to create a recursive method called method 

    three to have the call to itself depend on an if statement. 

    That way, eventually, when the if statement is false, 

    the method will stop repeating, 

    and we won't cause a stack overflow. 

    When this program starts, 

    we'll declare account and set it to four. 

    Then we'll output the A, and then we'll call method three 

    and send count four to it. 

    But before we go, we'll save the location to return to. 

    Then we'll execute method three, 

    and val will receive a copy of count. 

    So val is worth four. 

    We'll decide if val is greater than two. 

    It is, it's four. 

    So we'll output C and reduce val by one, making it three. 

    Then we'll call method three using the new parameter. 

    But before we go, we'll save the address to return to. 

    When method three executes, val is three. 

    We'll test to see if it's greater than two. 

    It is. So we'll output a C, reduce val to two. 

    And then when we call the method again, 

    we'll save where to come back to 

    and send a two in as a parameter. 

    This time, val is not greater than two, it is two. 

    So we go to the end if. 

    The next statement outputs a D. 

    And when we reach the return statement, 

    we take the top address out of the stack, and it tells us 

    to turn to the instruction that followed number eleven. 

    That's the end if. 

    So we output a D. And when we return, we take the next address 

    out of the stack, and it tells us to go 

    to the instruction that followed eleven. 

    That's end if, so we output a D. And when we return, 

    we take the next address out of the stack, and that tells us 

    to go to the instruction that followed four. 

    That's back in the main program, 

    and that outputs a B, and the program ends. 

    So by providing a way out of the recursive method, 

    we've successfully created a method 

    that can run recursively, but not infinitely. 

    Thanks for watching. 

   
